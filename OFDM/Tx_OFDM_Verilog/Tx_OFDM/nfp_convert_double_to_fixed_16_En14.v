// -------------------------------------------------------------
// 
// File Name: C:\Users\acer\OneDrive\Documents\ITS CAK V2\Magang\BRIN\Progress\Matlab Simulink\HDL Coder\proyek\OFDM\Tx_OFDM_Verilog\Tx_OFDM\nfp_convert_double_to_fixed_16_En14.v
// Created: 2023-06-11 16:01:44
// 
// Generated by MATLAB 9.14 and HDL Coder 4.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: nfp_convert_double_to_fixed_16_En14
// Source Path: Tx_OFDM/Transmitter/QAM Modulator/QAM Buffer/nfp_convert_double_to_fixed_16_En14
// Hierarchy Level: 3
// 
// {Latency Strategy = "Max"}
// 
// {Rounding Mode = Floor}
// {Overflow Mode = Wrap}
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module nfp_convert_double_to_fixed_16_En14
          (clk,
           reset,
           enb,
           nfp_in,
           nfp_out);


  input   clk;
  input   reset;
  input   enb;
  input   [63:0] nfp_in;  // ufix64
  output  signed [15:0] nfp_out;  // sfix16_En14


  wire In1;  // ufix1
  wire [10:0] In2;  // ufix11
  wire [51:0] In3;  // ufix52
  reg  [0:3] Delay8_reg;  // ufix1 [4]
  wire [0:3] Delay8_reg_next;  // ufix1 [4]
  wire Delay8_out1;  // ufix1
  reg [10:0] Delay3_out1;  // ufix11
  wire [15:0] Constant3_out1;  // uint16
  wire [15:0] Constant2_out1;  // uint16
  wire [15:0] Switch2_out1;  // uint16
  wire signed [11:0] Add_sub_cast;  // sfix12
  wire signed [11:0] Add_1;  // sfix12
  wire signed [11:0] alphave;  // sfix12
  reg signed [11:0] alphave_1;  // sfix12
  reg signed [11:0] alphave_2;  // sfix12
  wire switch_compare_1;
  wire Compare_To_Zero_out1;  // ufix1
  reg [51:0] Delay4_out1;  // ufix52
  wire [52:0] Bit_Concat_out1;  // ufix53
  wire [52:0] Data_Type_Conversion1_out1;  // ufix53_En52
  wire [54:0] Data_Type_Conversion1_out1_1;  // ufix55_En53
  reg [54:0] Data_Type_Conversion1_out1_2;  // ufix55_En53
  wire signed [12:0] Unary_Minus_in0;  // sfix13
  wire signed [12:0] Unary_Minus_1;  // sfix13
  wire signed [11:0] alphave_3;  // sfix12
  reg signed [11:0] Delay10_out1;  // sfix12
  wire signed [11:0] shift_arithmetic1_zerosig;  // sfix12
  wire signed [11:0] shift_arithmetic1_selsig;  // sfix12
  wire signed [11:0] shift_arithmetic1_zerosig_1;  // sfix12
  wire signed [11:0] shift_arithmetic1_selsig_1;  // sfix12
  wire signed [15:0] shift_arithmetic1_cast;  // int16
  wire [54:0] Shift_Arithmetic1_out1;  // ufix55_En53
  wire Compare_To_Zero1_out1;  // ufix1
  wire Compare_To_Zero_out1_1;  // ufix1
  wire Logical_Operator_out1;  // ufix1
  wire [54:0] Bit_Set_out1;  // ufix55_En53
  wire [54:0] Switch2_out1_1;  // ufix55_En53
  reg [54:0] Delay4_out1_1;  // ufix55_En53
  wire signed [11:0] shift_arithmetic2_zerosig;  // sfix12
  wire signed [11:0] shift_arithmetic2_selsig;  // sfix12
  wire signed [11:0] shift_arithmetic2_zerosig_1;  // sfix12
  wire signed [11:0] shift_arithmetic2_selsig_1;  // sfix12
  wire signed [15:0] shift_arithmetic2_cast;  // int16
  wire [54:0] Shift_Arithmetic2_out1;  // ufix55_En53
  reg [54:0] Delay6_out1;  // ufix55_En53
  wire [54:0] Switch1_out1;  // ufix55_En53
  reg [54:0] Delay2_out1;  // ufix55_En53
  wire signed [55:0] Data_Type_Conversion3_out1;  // sfix56_En53
  wire signed [56:0] Unary_Minus_cast;  // sfix57_En53
  wire signed [56:0] Unary_Minus_cast_1;  // sfix57_En53
  wire signed [55:0] Unary_Minus_out1;  // sfix56_En53
  wire signed [55:0] Switch1_out1_1;  // sfix56_En53
  reg signed [55:0] Delay1_out1;  // sfix56_En53
  wire signed [15:0] Data_Type_Conversion2_out1;  // sfix16_En14
  reg signed [15:0] Delay8_out1_1;  // sfix16_En14


  // Split 64 bit word into FP sign, exponent, mantissa
  assign In1 = nfp_in[63];
  assign In2 = nfp_in[62:52];
  assign In3 = nfp_in[51:0];



  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        Delay8_reg[0] <= 1'b0;
        Delay8_reg[1] <= 1'b0;
        Delay8_reg[2] <= 1'b0;
        Delay8_reg[3] <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay8_reg[0] <= Delay8_reg_next[0];
          Delay8_reg[1] <= Delay8_reg_next[1];
          Delay8_reg[2] <= Delay8_reg_next[2];
          Delay8_reg[3] <= Delay8_reg_next[3];
        end
      end
    end

  assign Delay8_out1 = Delay8_reg[3];
  assign Delay8_reg_next[0] = In1;
  assign Delay8_reg_next[1] = Delay8_reg[0];
  assign Delay8_reg_next[2] = Delay8_reg[1];
  assign Delay8_reg_next[3] = Delay8_reg[2];



  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 11'b00000000000;
      end
      else begin
        if (enb) begin
          Delay3_out1 <= In2;
        end
      end
    end



  assign Constant3_out1 = 16'b0000001111111110;



  assign Constant2_out1 = 16'b0000001111111111;



  assign Switch2_out1 = (Delay3_out1 == 11'b00000000000 ? Constant3_out1 :
              Constant2_out1);



  assign Add_sub_cast = $signed(Switch2_out1[11:0]);
  assign Add_1 = {1'b0, Delay3_out1};
  assign alphave = Add_1 - Add_sub_cast;



  always @(posedge clk or posedge reset)
    begin : reduced_process
      if (reset == 1'b1) begin
        alphave_1 <= 12'sb000000000000;
      end
      else begin
        if (enb) begin
          alphave_1 <= alphave;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reduced_1_process
      if (reset == 1'b1) begin
        alphave_2 <= 12'sb000000000000;
      end
      else begin
        if (enb) begin
          alphave_2 <= alphave_1;
        end
      end
    end



  assign switch_compare_1 = alphave_2 >= 12'sb000000000000;



  assign Compare_To_Zero_out1 = Delay3_out1 != 11'b00000000000;



  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 52'h0000000000000;
      end
      else begin
        if (enb) begin
          Delay4_out1 <= In3;
        end
      end
    end



  assign Bit_Concat_out1 = {Compare_To_Zero_out1, Delay4_out1};



  assign Data_Type_Conversion1_out1 = Bit_Concat_out1;



  assign Data_Type_Conversion1_out1_1 = {1'b0, {Data_Type_Conversion1_out1, 1'b0}};



  always @(posedge clk or posedge reset)
    begin : reduced_2_process
      if (reset == 1'b1) begin
        Data_Type_Conversion1_out1_2 <= 55'h00000000000000;
      end
      else begin
        if (enb) begin
          Data_Type_Conversion1_out1_2 <= Data_Type_Conversion1_out1_1;
        end
      end
    end



  assign Unary_Minus_1 = {alphave[11], alphave};
  assign Unary_Minus_in0 =  - (Unary_Minus_1);
  assign alphave_3 = Unary_Minus_in0[11:0];



  always @(posedge clk or posedge reset)
    begin : Delay10_process
      if (reset == 1'b1) begin
        Delay10_out1 <= 12'sb000000000000;
      end
      else begin
        if (enb) begin
          Delay10_out1 <= alphave_3;
        end
      end
    end



  assign shift_arithmetic1_zerosig = 12'sb000000000000;



  assign shift_arithmetic1_selsig = (Delay10_out1 >= shift_arithmetic1_zerosig ? Delay10_out1 :
              shift_arithmetic1_zerosig);



  assign shift_arithmetic1_zerosig_1 = 12'sb000000000000;



  assign shift_arithmetic1_selsig_1 = (shift_arithmetic1_selsig >= shift_arithmetic1_zerosig_1 ? shift_arithmetic1_selsig :
              shift_arithmetic1_zerosig_1);



  assign shift_arithmetic1_cast = {{4{shift_arithmetic1_selsig_1[11]}}, shift_arithmetic1_selsig_1};
  assign Shift_Arithmetic1_out1 = Data_Type_Conversion1_out1_2 >>> shift_arithmetic1_cast;



  assign Compare_To_Zero1_out1 = Shift_Arithmetic1_out1 == 55'h00000000000000;



  assign Compare_To_Zero_out1_1 = Data_Type_Conversion1_out1_2 != 55'h00000000000000;



  assign Logical_Operator_out1 = Compare_To_Zero1_out1 & Compare_To_Zero_out1_1;



  assign Bit_Set_out1 = Shift_Arithmetic1_out1 | 55'h00000000000001;



  assign Switch2_out1_1 = (Logical_Operator_out1 == 1'b0 ? Shift_Arithmetic1_out1 :
              Bit_Set_out1);



  always @(posedge clk or posedge reset)
    begin : Delay4_1_process
      if (reset == 1'b1) begin
        Delay4_out1_1 <= 55'h00000000000000;
      end
      else begin
        if (enb) begin
          Delay4_out1_1 <= Switch2_out1_1;
        end
      end
    end



  assign shift_arithmetic2_zerosig = 12'sb000000000000;



  assign shift_arithmetic2_selsig = (alphave_1 >= shift_arithmetic2_zerosig ? alphave_1 :
              shift_arithmetic2_zerosig);



  assign shift_arithmetic2_zerosig_1 = 12'sb000000000000;



  assign shift_arithmetic2_selsig_1 = (shift_arithmetic2_selsig >= shift_arithmetic2_zerosig_1 ? shift_arithmetic2_selsig :
              shift_arithmetic2_zerosig_1);



  assign shift_arithmetic2_cast = {{4{shift_arithmetic2_selsig_1[11]}}, shift_arithmetic2_selsig_1};
  assign Shift_Arithmetic2_out1 = Data_Type_Conversion1_out1_2 <<< shift_arithmetic2_cast;



  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_out1 <= 55'h00000000000000;
      end
      else begin
        if (enb) begin
          Delay6_out1 <= Shift_Arithmetic2_out1;
        end
      end
    end



  assign Switch1_out1 = (switch_compare_1 == 1'b0 ? Delay4_out1_1 :
              Delay6_out1);



  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 55'h00000000000000;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= Switch1_out1;
        end
      end
    end



  assign Data_Type_Conversion3_out1 = {1'b0, Delay2_out1};



  assign Unary_Minus_cast = {Data_Type_Conversion3_out1[55], Data_Type_Conversion3_out1};
  assign Unary_Minus_cast_1 =  - (Unary_Minus_cast);
  assign Unary_Minus_out1 = Unary_Minus_cast_1[55:0];



  assign Switch1_out1_1 = (Delay8_out1 == 1'b0 ? Data_Type_Conversion3_out1 :
              Unary_Minus_out1);



  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 56'sh00000000000000;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= Switch1_out1_1;
        end
      end
    end



  assign Data_Type_Conversion2_out1 = Delay1_out1[54:39];



  always @(posedge clk or posedge reset)
    begin : Delay8_1_process
      if (reset == 1'b1) begin
        Delay8_out1_1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay8_out1_1 <= Data_Type_Conversion2_out1;
        end
      end
    end



  assign nfp_out = Delay8_out1_1;

endmodule  // nfp_convert_double_to_fixed_16_En14

