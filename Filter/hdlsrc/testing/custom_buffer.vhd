-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\testing\custom_buffer.vhd
-- Created: 2023-04-09 11:40:40
-- 
-- Generated by MATLAB 9.14 and HDL Coder 4.1
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1
-- Target subsystem base rate: 1
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- buffer1_re                    ce_out        1
-- buffer1_im                    ce_out        1
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: custom_buffer
-- Source Path: testing/custom buffer
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.custom_buffer_pkg.ALL;

ENTITY custom_buffer IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        value_re                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        value_im                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        ce_out                            :   OUT   std_logic;
        buffer1_re                        :   OUT   vector_of_std_logic_vector16(0 TO 3);  -- sfix16_En14 [4]
        buffer1_im                        :   OUT   vector_of_std_logic_vector16(0 TO 3)  -- sfix16_En14 [4]
        );
END custom_buffer;


ARCHITECTURE rtl OF custom_buffer IS

  -- Component Declarations
  COMPONENT vector_initialization
    PORT( y_re                            :   OUT   vector_of_std_logic_vector64(0 TO 3);  -- double [4]
          y_im                            :   OUT   vector_of_std_logic_vector64(0 TO 3)  -- double [4]
          );
  END COMPONENT;

  COMPONENT nfp_convert_double_to_fixed_16_En14
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in                          :   IN    std_logic_vector(63 DOWNTO 0);  -- double
          nfp_out                         :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En14
          );
  END COMPONENT;

  COMPONENT vector_feedback
    PORT( vector_before_re                :   IN    vector_of_std_logic_vector16(0 TO 3);  -- sfix16_En14 [4]
          vector_before_im                :   IN    vector_of_std_logic_vector16(0 TO 3);  -- sfix16_En14 [4]
          y_re                            :   OUT   vector_of_std_logic_vector16(0 TO 3);  -- sfix16_En14 [4]
          y_im                            :   OUT   vector_of_std_logic_vector16(0 TO 3)  -- sfix16_En14 [4]
          );
  END COMPONENT;

  COMPONENT buffer_rsvd
    PORT( value_re                        :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          value_im                        :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
          vector_zero_re                  :   IN    vector_of_std_logic_vector16(0 TO 3);  -- sfix16_En14 [4]
          vector_zero_im                  :   IN    vector_of_std_logic_vector16(0 TO 3);  -- sfix16_En14 [4]
          vector_before_re                :   IN    vector_of_std_logic_vector16(0 TO 3);  -- sfix16_En14 [4]
          vector_before_im                :   IN    vector_of_std_logic_vector16(0 TO 3);  -- sfix16_En14 [4]
          counter                         :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          buffer_re                       :   OUT   vector_of_std_logic_vector16(0 TO 3);  -- sfix16_En14 [4]
          buffer_im                       :   OUT   vector_of_std_logic_vector16(0 TO 3)  -- sfix16_En14 [4]
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : vector_initialization
    USE ENTITY work.vector_initialization(rtl);

  FOR ALL : nfp_convert_double_to_fixed_16_En14
    USE ENTITY work.nfp_convert_double_to_fixed_16_En14(rtl);

  FOR ALL : vector_feedback
    USE ENTITY work.vector_feedback(rtl);

  FOR ALL : buffer_rsvd
    USE ENTITY work.buffer_rsvd(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL value_re_signed                  : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL value_im_signed                  : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL delayMatch1_reg_re               : vector_of_signed16(0 TO 5);  -- sfix16_En15 [6]
  SIGNAL delayMatch1_reg_im               : vector_of_signed16(0 TO 5);  -- sfix16_En15 [6]
  SIGNAL delayMatch1_reg_next_re          : vector_of_signed16(0 TO 5);  -- sfix16_En15 [6]
  SIGNAL delayMatch1_reg_next_im          : vector_of_signed16(0 TO 5);  -- sfix16_En15 [6]
  SIGNAL value_re_1                       : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL value_im_1                       : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL y_re                             : vector_of_std_logic_vector64(0 TO 3);  -- ufix64 [4]
  SIGNAL y_im                             : vector_of_std_logic_vector64(0 TO 3);  -- ufix64 [4]
  SIGNAL Data_Type_Conversion_out1_re     : vector_of_std_logic_vector16(0 TO 3);  -- ufix16 [4]
  SIGNAL Data_Type_Conversion_out1_im     : vector_of_std_logic_vector16(0 TO 3);  -- ufix16 [4]
  SIGNAL stateControl_1                   : std_logic;
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 5);  -- ufix1 [6]
  SIGNAL delayMatch_reg_next              : std_logic_vector(0 TO 5);  -- ufix1 [6]
  SIGNAL stateControl_2                   : std_logic;
  SIGNAL HDL_Counter_ctrl_const_out       : std_logic;
  SIGNAL HDL_Counter_ctrl_delay_out       : std_logic;
  SIGNAL HDL_Counter_Initial_Val_out      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL count_step                       : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL count_from                       : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL HDL_Counter_out1                 : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL count                            : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL need_to_wrap                     : std_logic;
  SIGNAL count_value                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL HDL_Counter_out                  : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL delayMatch2_reg                  : vector_of_unsigned8(0 TO 5);  -- ufix8 [6]
  SIGNAL delayMatch2_reg_next             : vector_of_unsigned8(0 TO 5);  -- ufix8 [6]
  SIGNAL HDL_Counter_out1_1               : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Delay_out1_im                    : vector_of_signed16(0 TO 3);  -- sfix16_En14 [4]
  SIGNAL Delay_out1_im_1                  : vector_of_std_logic_vector16(0 TO 3);  -- ufix16 [4]
  SIGNAL buffer_im                        : vector_of_std_logic_vector16(0 TO 3);  -- ufix16 [4]
  SIGNAL buffer_im_signed                 : vector_of_signed16(0 TO 3);  -- sfix16_En14 [4]
  SIGNAL buffer_re                        : vector_of_std_logic_vector16(0 TO 3);  -- ufix16 [4]
  SIGNAL buffer_re_signed                 : vector_of_signed16(0 TO 3);  -- sfix16_En14 [4]
  SIGNAL Delay_out1_re                    : vector_of_signed16(0 TO 3);  -- sfix16_En14 [4]
  SIGNAL buffer_re_1                      : vector_of_signed16(0 TO 3);  -- sfix16_En14 [4]
  SIGNAL buffer_im_1                      : vector_of_signed16(0 TO 3);  -- sfix16_En14 [4]
  SIGNAL Delay_out1_re_1                  : vector_of_std_logic_vector16(0 TO 3);  -- ufix16 [4]
  SIGNAL y_re_1                           : vector_of_std_logic_vector16(0 TO 3);  -- ufix16 [4]
  SIGNAL y_im_1                           : vector_of_std_logic_vector16(0 TO 3);  -- ufix16 [4]

BEGIN
  u_vector_initialization : vector_initialization
    PORT MAP( y_re => y_re,  -- double [4]
              y_im => y_im  -- double [4]
              );

  u_testing_custom_buffer_nfp_convert_double_to_fixed_16_En14 : nfp_convert_double_to_fixed_16_En14
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              nfp_in => y_re(0),  -- double
              nfp_out => Data_Type_Conversion_out1_re(0)  -- sfix16_En14
              );

  u_testing_custom_buffer_nfp_convert_double_to_fixed_16_En14_1 : nfp_convert_double_to_fixed_16_En14
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              nfp_in => y_re(1),  -- double
              nfp_out => Data_Type_Conversion_out1_re(1)  -- sfix16_En14
              );

  u_testing_custom_buffer_nfp_convert_double_to_fixed_16_En14_2 : nfp_convert_double_to_fixed_16_En14
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              nfp_in => y_re(2),  -- double
              nfp_out => Data_Type_Conversion_out1_re(2)  -- sfix16_En14
              );

  u_testing_custom_buffer_nfp_convert_double_to_fixed_16_En14_3 : nfp_convert_double_to_fixed_16_En14
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              nfp_in => y_im(0),  -- double
              nfp_out => Data_Type_Conversion_out1_im(0)  -- sfix16_En14
              );

  u_testing_custom_buffer_nfp_convert_double_to_fixed_16_En14_4 : nfp_convert_double_to_fixed_16_En14
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              nfp_in => y_im(1),  -- double
              nfp_out => Data_Type_Conversion_out1_im(1)  -- sfix16_En14
              );

  u_testing_custom_buffer_nfp_convert_double_to_fixed_16_En14_5 : nfp_convert_double_to_fixed_16_En14
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              nfp_in => y_im(2),  -- double
              nfp_out => Data_Type_Conversion_out1_im(2)  -- sfix16_En14
              );

  u_testing_custom_buffer_nfp_convert_double_to_fixed_16_En14_6 : nfp_convert_double_to_fixed_16_En14
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              nfp_in => y_re(3),  -- double
              nfp_out => Data_Type_Conversion_out1_re(3)  -- sfix16_En14
              );

  u_testing_custom_buffer_nfp_convert_double_to_fixed_16_En14_7 : nfp_convert_double_to_fixed_16_En14
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              nfp_in => y_im(3),  -- double
              nfp_out => Data_Type_Conversion_out1_im(3)  -- sfix16_En14
              );

  u_vector_feedback : vector_feedback
    PORT MAP( vector_before_re => Delay_out1_re_1,  -- sfix16_En14 [4]
              vector_before_im => Delay_out1_im_1,  -- sfix16_En14 [4]
              y_re => y_re_1,  -- sfix16_En14 [4]
              y_im => y_im_1  -- sfix16_En14 [4]
              );

  u_buffer : buffer_rsvd
    PORT MAP( value_re => std_logic_vector(value_re_1),  -- sfix16_En15
              value_im => std_logic_vector(value_im_1),  -- sfix16_En15
              vector_zero_re => Data_Type_Conversion_out1_re,  -- sfix16_En14 [4]
              vector_zero_im => Data_Type_Conversion_out1_im,  -- sfix16_En14 [4]
              vector_before_re => y_re_1,  -- sfix16_En14 [4]
              vector_before_im => y_im_1,  -- sfix16_En14 [4]
              counter => std_logic_vector(HDL_Counter_out1_1),  -- uint8
              buffer_re => buffer_re,  -- sfix16_En14 [4]
              buffer_im => buffer_im  -- sfix16_En14 [4]
              );

  value_re_signed <= signed(value_re);

  value_im_signed <= signed(value_im);

  enb <= clk_enable;

  delayMatch1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch1_reg_re(0) <= to_signed(16#0000#, 16);
      delayMatch1_reg_im(0) <= to_signed(16#0000#, 16);
      delayMatch1_reg_re(1) <= to_signed(16#0000#, 16);
      delayMatch1_reg_im(1) <= to_signed(16#0000#, 16);
      delayMatch1_reg_re(2) <= to_signed(16#0000#, 16);
      delayMatch1_reg_im(2) <= to_signed(16#0000#, 16);
      delayMatch1_reg_re(3) <= to_signed(16#0000#, 16);
      delayMatch1_reg_im(3) <= to_signed(16#0000#, 16);
      delayMatch1_reg_re(4) <= to_signed(16#0000#, 16);
      delayMatch1_reg_im(4) <= to_signed(16#0000#, 16);
      delayMatch1_reg_re(5) <= to_signed(16#0000#, 16);
      delayMatch1_reg_im(5) <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch1_reg_re(0) <= delayMatch1_reg_next_re(0);
        delayMatch1_reg_im(0) <= delayMatch1_reg_next_im(0);
        delayMatch1_reg_re(1) <= delayMatch1_reg_next_re(1);
        delayMatch1_reg_im(1) <= delayMatch1_reg_next_im(1);
        delayMatch1_reg_re(2) <= delayMatch1_reg_next_re(2);
        delayMatch1_reg_im(2) <= delayMatch1_reg_next_im(2);
        delayMatch1_reg_re(3) <= delayMatch1_reg_next_re(3);
        delayMatch1_reg_im(3) <= delayMatch1_reg_next_im(3);
        delayMatch1_reg_re(4) <= delayMatch1_reg_next_re(4);
        delayMatch1_reg_im(4) <= delayMatch1_reg_next_im(4);
        delayMatch1_reg_re(5) <= delayMatch1_reg_next_re(5);
        delayMatch1_reg_im(5) <= delayMatch1_reg_next_im(5);
      END IF;
    END IF;
  END PROCESS delayMatch1_process;

  value_re_1 <= delayMatch1_reg_re(5);
  value_im_1 <= delayMatch1_reg_im(5);
  delayMatch1_reg_next_re(0) <= value_re_signed;
  delayMatch1_reg_next_im(0) <= value_im_signed;
  delayMatch1_reg_next_re(1) <= delayMatch1_reg_re(0);
  delayMatch1_reg_next_im(1) <= delayMatch1_reg_im(0);
  delayMatch1_reg_next_re(2) <= delayMatch1_reg_re(1);
  delayMatch1_reg_next_im(2) <= delayMatch1_reg_im(1);
  delayMatch1_reg_next_re(3) <= delayMatch1_reg_re(2);
  delayMatch1_reg_next_im(3) <= delayMatch1_reg_im(2);
  delayMatch1_reg_next_re(4) <= delayMatch1_reg_re(3);
  delayMatch1_reg_next_im(4) <= delayMatch1_reg_im(3);
  delayMatch1_reg_next_re(5) <= delayMatch1_reg_re(4);
  delayMatch1_reg_next_im(5) <= delayMatch1_reg_im(4);



  stateControl_1 <= '1';

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg(0) <= '0';
      delayMatch_reg(1) <= '0';
      delayMatch_reg(2) <= '0';
      delayMatch_reg(3) <= '0';
      delayMatch_reg(4) <= '0';
      delayMatch_reg(5) <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch_reg(0) <= delayMatch_reg_next(0);
        delayMatch_reg(1) <= delayMatch_reg_next(1);
        delayMatch_reg(2) <= delayMatch_reg_next(2);
        delayMatch_reg(3) <= delayMatch_reg_next(3);
        delayMatch_reg(4) <= delayMatch_reg_next(4);
        delayMatch_reg(5) <= delayMatch_reg_next(5);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  stateControl_2 <= delayMatch_reg(5);
  delayMatch_reg_next(0) <= stateControl_1;
  delayMatch_reg_next(1) <= delayMatch_reg(0);
  delayMatch_reg_next(2) <= delayMatch_reg(1);
  delayMatch_reg_next(3) <= delayMatch_reg(2);
  delayMatch_reg_next(4) <= delayMatch_reg(3);
  delayMatch_reg_next(5) <= delayMatch_reg(4);

  HDL_Counter_ctrl_const_out <= '1';

  HDL_Counter_ctrl_delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      HDL_Counter_ctrl_delay_out <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        HDL_Counter_ctrl_delay_out <= HDL_Counter_ctrl_const_out;
      END IF;
    END IF;
  END PROCESS HDL_Counter_ctrl_delay_process;


  HDL_Counter_Initial_Val_out <= to_unsigned(16#01#, 8);

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 4
  count_step <= to_unsigned(16#01#, 8);

  count_from <= to_unsigned(16#01#, 8);

  count <= HDL_Counter_out1 + count_step;

  
  need_to_wrap <= '1' WHEN HDL_Counter_out1 = to_unsigned(16#04#, 8) ELSE
      '0';

  
  count_value <= count WHEN need_to_wrap = '0' ELSE
      count_from;

  HDL_Counter_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      HDL_Counter_out <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        HDL_Counter_out <= count_value;
      END IF;
    END IF;
  END PROCESS HDL_Counter_process;


  
  HDL_Counter_out1 <= HDL_Counter_Initial_Val_out WHEN HDL_Counter_ctrl_delay_out = '0' ELSE
      HDL_Counter_out;

  delayMatch2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch2_reg(0) <= to_unsigned(16#00#, 8);
      delayMatch2_reg(1) <= to_unsigned(16#00#, 8);
      delayMatch2_reg(2) <= to_unsigned(16#00#, 8);
      delayMatch2_reg(3) <= to_unsigned(16#00#, 8);
      delayMatch2_reg(4) <= to_unsigned(16#00#, 8);
      delayMatch2_reg(5) <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch2_reg(0) <= delayMatch2_reg_next(0);
        delayMatch2_reg(1) <= delayMatch2_reg_next(1);
        delayMatch2_reg(2) <= delayMatch2_reg_next(2);
        delayMatch2_reg(3) <= delayMatch2_reg_next(3);
        delayMatch2_reg(4) <= delayMatch2_reg_next(4);
        delayMatch2_reg(5) <= delayMatch2_reg_next(5);
      END IF;
    END IF;
  END PROCESS delayMatch2_process;

  HDL_Counter_out1_1 <= delayMatch2_reg(5);
  delayMatch2_reg_next(0) <= HDL_Counter_out1;
  delayMatch2_reg_next(1) <= delayMatch2_reg(0);
  delayMatch2_reg_next(2) <= delayMatch2_reg(1);
  delayMatch2_reg_next(3) <= delayMatch2_reg(2);
  delayMatch2_reg_next(4) <= delayMatch2_reg(3);
  delayMatch2_reg_next(5) <= delayMatch2_reg(4);

  outputgen3: FOR k IN 0 TO 3 GENERATE
    Delay_out1_im_1(k) <= std_logic_vector(Delay_out1_im(k));
  END GENERATE;

  outputgen2: FOR k IN 0 TO 3 GENERATE
    buffer_im_signed(k) <= signed(buffer_im(k));
  END GENERATE;

  outputgen1: FOR k IN 0 TO 3 GENERATE
    buffer_re_signed(k) <= signed(buffer_re(k));
  END GENERATE;

  
  buffer_re_1(0) <= Delay_out1_re(0) WHEN stateControl_2 = '0' ELSE
      buffer_re_signed(0);
  
  buffer_re_1(1) <= Delay_out1_re(1) WHEN stateControl_2 = '0' ELSE
      buffer_re_signed(1);
  
  buffer_re_1(2) <= Delay_out1_re(2) WHEN stateControl_2 = '0' ELSE
      buffer_re_signed(2);
  
  buffer_re_1(3) <= Delay_out1_re(3) WHEN stateControl_2 = '0' ELSE
      buffer_re_signed(3);
  
  buffer_im_1(0) <= Delay_out1_im(0) WHEN stateControl_2 = '0' ELSE
      buffer_im_signed(0);
  
  buffer_im_1(1) <= Delay_out1_im(1) WHEN stateControl_2 = '0' ELSE
      buffer_im_signed(1);
  
  buffer_im_1(2) <= Delay_out1_im(2) WHEN stateControl_2 = '0' ELSE
      buffer_im_signed(2);
  
  buffer_im_1(3) <= Delay_out1_im(3) WHEN stateControl_2 = '0' ELSE
      buffer_im_signed(3);

  Delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_out1_re(0) <= to_signed(16#0000#, 16);
      Delay_out1_im(0) <= to_signed(16#0000#, 16);
      Delay_out1_re(1) <= to_signed(16#0000#, 16);
      Delay_out1_im(1) <= to_signed(16#0000#, 16);
      Delay_out1_re(2) <= to_signed(16#0000#, 16);
      Delay_out1_im(2) <= to_signed(16#0000#, 16);
      Delay_out1_re(3) <= to_signed(16#0000#, 16);
      Delay_out1_im(3) <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay_out1_re(0) <= buffer_re_1(0);
        Delay_out1_im(0) <= buffer_im_1(0);
        Delay_out1_re(1) <= buffer_re_1(1);
        Delay_out1_im(1) <= buffer_im_1(1);
        Delay_out1_re(2) <= buffer_re_1(2);
        Delay_out1_im(2) <= buffer_im_1(2);
        Delay_out1_re(3) <= buffer_re_1(3);
        Delay_out1_im(3) <= buffer_im_1(3);
      END IF;
    END IF;
  END PROCESS Delay_process;


  outputgen: FOR k IN 0 TO 3 GENERATE
    Delay_out1_re_1(k) <= std_logic_vector(Delay_out1_re(k));
  END GENERATE;

  ce_out <= clk_enable;

  buffer1_re <= buffer_re;

  buffer1_im <= buffer_im;

END rtl;

